<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>秋叶PPT教程（一）</title>
      <link href="/2022/06/18/skills/ppt1/"/>
      <url>/2022/06/18/skills/ppt1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1HA411J7iZ?p=2">https://www.bilibili.com/video/BV1HA411J7iZ?p=2</a></p><h1 id="1-纯文字制作高大上的个人介绍"><a href="#1-纯文字制作高大上的个人介绍" class="headerlink" title="1.  纯文字制作高大上的个人介绍"></a>1.  纯文字制作高大上的个人介绍</h1><blockquote><ol><li> 区分单行文本框和段落文本框</li><li>把PPT页面当画布，每一个文本框都是一个单独的对象</li><li>为大段的文字段落设置合适的“行距”能够增加文字的“透气性”，使之更易于阅读，推荐设置1.2或1.3倍行距。</li><li>宋体加粗 32，思源黑体CN Bold 36</li><li>大段文字不要使用纯黑，使用深灰色（浅黑），可以降低阅读时的压迫感，营造更好的阅读体验</li></ol></blockquote><h1 id="2-运用字体打造个性化人物介绍"><a href="#2-运用字体打造个性化人物介绍" class="headerlink" title="2.  运用字体打造个性化人物介绍"></a>2.  运用字体打造个性化人物介绍</h1><blockquote><ol><li><p> 找字网（非指定字体）：<a href="http://www.zhaozi.cn/">http://www.zhaozi.cn/</a></p></li><li><p>求字网（特定字体，不知名字）：<a href="https://www.qiuziti.com/">https://www.qiuziti.com/</a></p></li></ol></blockquote><h1 id="3-不拘一格才能玩出创意"><a href="#3-不拘一格才能玩出创意" class="headerlink" title="3.  不拘一格才能玩出创意"></a>3.  不拘一格才能玩出创意</h1><h1 id="4-简单快速制作封面页"><a href="#4-简单快速制作封面页" class="headerlink" title="4.  简单快速制作封面页"></a>4.  简单快速制作封面页</h1><h1 id="5-干净清爽的目录页"><a href="#5-干净清爽的目录页" class="headerlink" title="5.  干净清爽的目录页"></a>5.  干净清爽的目录页</h1><blockquote><p>ctrl shift 拉动，可以复制新的形状</p><p>选中形状，f4可以重复上一步的操作</p></blockquote><p><img src="/ppt1" alt="pic"></p><p>梯形页待续</p><h1 id="6-结构明晰的内容页"><a href="#6-结构明晰的内容页" class="headerlink" title="6.  结构明晰的内容页"></a>6.  结构明晰的内容页</h1><p><img src="/ppt1" alt="2"></p><h1 id="7-省时高效的排版技巧"><a href="#7-省时高效的排版技巧" class="headerlink" title="7.  省时高效的排版技巧"></a>7.  省时高效的排版技巧</h1><p>幻灯片母版</p><p>母版中的元素，在页面中无法被选中、修改，因此不能把需要有变化的文字（如页面小标题）直接以文本框的方式放入母版内，只能采取插入占位符的方式。</p>]]></content>
      
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> ppt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT素材库</title>
      <link href="/2022/06/18/skills/ppt0/"/>
      <url>/2022/06/18/skills/ppt0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-素材"><a href="#1-素材" class="headerlink" title="1.  素材"></a>1.  素材</h1><h2 id="1-0-模板"><a href="#1-0-模板" class="headerlink" title="1.0  模板"></a>1.0  模板</h2><h3 id="1-0-1-学习网站"><a href="#1-0-1-学习网站" class="headerlink" title="1.0.1  学习网站"></a>1.0.1  学习网站</h3><p><a href="https://www.bilibili.com/video/BV1x4411p7LV?p=2">https://www.bilibili.com/video/BV1x4411p7LV?p=2</a></p><h3 id="1-0-2-ppt模板"><a href="#1-0-2-ppt模板" class="headerlink" title="1.0.2  ppt模板"></a>1.0.2  ppt模板</h3><p><strong>免费：</strong></p><p><a href="http://www.ypppt.com/%EF%BC%88%E6%84%9F%E8%A7%89%E6%B2%A1%E5%95%A5%E5%A5%BD%E7%9C%8B%E7%9A%84%EF%BC%89">http://www.ypppt.com/（感觉没啥好看的）</a></p><p><a href="http://ppt.sotary.com/web/wxapp/index.html">http://ppt.sotary.com/web/wxapp/index.html</a> （ppt超级市场）</p><p><a href="http://www.1ppt.com/moban/keji/ppt_keji_3.html">http://www.1ppt.com/moban/keji/ppt_keji_3.html</a> </p><p><a href="http://www.51pptmoban.com/">http://www.51pptmoban.com/</a> （51ppt）</p><p><a href="https://www.ypppt.com/%EF%BC%88%E4%BC%98%E5%93%81ppt%EF%BC%89">https://www.ypppt.com/（优品ppt）</a></p><p><a href="https://www.dingdangsheji.com/%EF%BC%88%E5%8F%AE%E5%BD%93%E8%AE%BE%E8%AE%A1%EF%BC%89">https://www.dingdangsheji.com/（叮当设计）</a></p><h3 id="1-0-3-ppt插件"><a href="#1-0-3-ppt插件" class="headerlink" title="1.0.3  ppt插件"></a>1.0.3  ppt插件</h3><p><a href="https://www.islide.cc/install">https://www.islide.cc/install</a></p><h2 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1.1  map"></a>1.1  map</h2><h3 id="1-1-1-City-roads"><a href="#1-1-1-City-roads" class="headerlink" title="1.1.1  City roads"></a>1.1.1  City roads</h3><p><a href="https://anvaka.github.io/city-roads/">https://anvaka.github.io/city-roads/</a> </p><p>City roads 是一个让人惊艳的路网地图生成网站，它可以一键生成全球任意城市的路网地图，你可以修改路网地图的背景颜色和线条颜色，生成多张不同风格的路网地图。 </p><h3 id="1-1-2-地图生成器"><a href="#1-1-2-地图生成器" class="headerlink" title="1.1.2  地图生成器"></a>1.1.2  地图生成器</h3><p><a href="http://datav.aliyun.com/tools/atlas/#&amp;lat=31.769817845138945&amp;lng=104.29901249999999&amp;zoom=4">http://datav.aliyun.com/tools/atlas/#&amp;lat=31.769817845138945&amp;lng=104.29901249999999&amp;zoom=4</a> </p><h2 id="1-2-细节"><a href="#1-2-细节" class="headerlink" title="1.2  细节"></a>1.2  细节</h2><h3 id="1-2-1-字体"><a href="#1-2-1-字体" class="headerlink" title="1.2.1  字体"></a>1.2.1  字体</h3><p><a href="http://www.qiuziti.com(求字体)/">http://www.qiuziti.com（求字体）</a></p><h3 id="1-2-2-图表"><a href="#1-2-2-图表" class="headerlink" title="1.2.2  图表"></a>1.2.2  图表</h3><p><a href="http://echarts.apache.org/">http://echarts.apache.org</a></p><h2 id="1-3-picture"><a href="#1-3-picture" class="headerlink" title="1.3  picture"></a>1.3  picture</h2><h3 id="1-3-1-collections"><a href="#1-3-1-collections" class="headerlink" title="1.3.1  collections"></a>1.3.1  collections</h3><h4 id="1-3-1-1-pexels"><a href="#1-3-1-1-pexels" class="headerlink" title="1.3.1.1  pexels"></a>1.3.1.1  pexels</h4><p> <a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a> </p><p> <a href="https://wallhaven.cc/">https://wallhaven.cc/</a> （这个网站nb）</p><p><a href="https://pixabay.com/zh/images/search/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/?pagi=4&amp;%EF%BC%88%E5%BE%88%E5%BC%BA%EF%BC%89">https://pixabay.com/zh/images/search/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/?pagi=4&amp;（很强）</a></p><h4 id="1-3-1-2-矢量图库"><a href="#1-3-1-2-矢量图库" class="headerlink" title="1.3.1.2  矢量图库"></a>1.3.1.2  矢量图库</h4><p> <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a> </p><p><a href="https://www.iconfont.cn/%EF%BC%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87%E5%BA%93%EF%BC%89">https://www.iconfont.cn/（阿里巴巴矢量图标库）</a></p><h4 id="1-3-1-3-png免抠"><a href="#1-3-1-3-png免抠" class="headerlink" title="1.3.1.3  png免抠"></a>1.3.1.3  png免抠</h4><p>觅元素  <a href="http://www.51yuansu.com/">http://www.51yuansu.com/</a> （每个qq号有3次免费下载机会）</p><p>新图网  <a href="https://ixintu.com/sucai/7SQkajjeV.html">https://ixintu.com/sucai/7SQkajjeV.html</a> </p><h4 id="1-3-1-4-图片搜索"><a href="#1-3-1-4-图片搜索" class="headerlink" title="1.3.1.4  图片搜索"></a>1.3.1.4  图片搜索</h4><p>google识图： <a href="https://www.google.com.hk/imghp?hl=zh-CN">https://www.google.com.hk/imghp?hl=zh-CN</a> </p><p>百度识图： <a href="https://image.baidu.com/?fr=shitu">https://image.baidu.com/?fr=shitu</a> </p><p> <a href="https://zhuanlan.zhihu.com/p/52693499">https://zhuanlan.zhihu.com/p/52693499</a> </p><h3 id="1-3-2-features"><a href="#1-3-2-features" class="headerlink" title="1.3.2  features"></a>1.3.2  features</h3><h4 id="1-3-2-1-中国色"><a href="#1-3-2-1-中国色" class="headerlink" title="1.3.2.1  中国色"></a>1.3.2.1  中国色</h4><p> <a href="http://zhongguose.com/">http://zhongguose.com/</a> </p><h4 id="1-3-2-2-航拍"><a href="#1-3-2-2-航拍" class="headerlink" title="1.3.2.2  航拍"></a>1.3.2.2  航拍</h4><p>天空之城 <a href="https://www.5ce.com/?t=zhihu&amp;id=398193048">https://www.5ce.com/?t=zhihu&amp;id=398193048</a> （内容神器）</p><h4 id="1-3-2-3-液态星球"><a href="#1-3-2-3-液态星球" class="headerlink" title="1.3.2.3  液态星球"></a>1.3.2.3  液态星球</h4><p> <a href="https://alteredqualia.com/xg/examples/nebula_artefact.html">https://alteredqualia.com/xg/examples/nebula_artefact.html</a> </p><h4 id="1-3-2-4-街头艺术"><a href="#1-3-2-4-街头艺术" class="headerlink" title="1.3.2.4  街头艺术"></a>1.3.2.4  街头艺术</h4><p> <a href="https://streetartutopia.com/">https://streetartutopia.com/</a> </p><h4 id="1-3-2-5-衍纸效果"><a href="#1-3-2-5-衍纸效果" class="headerlink" title="1.3.2.5  衍纸效果"></a>1.3.2.5  衍纸效果</h4><p> <a href="https://pissang.github.io/paper-quilling-art/">https://pissang.github.io/paper-quilling-art/</a> </p><h2 id="1-4-tools"><a href="#1-4-tools" class="headerlink" title="1.4  tools"></a>1.4  tools</h2><h3 id="1-4-1-在线抠图"><a href="#1-4-1-在线抠图" class="headerlink" title="1.4.1  在线抠图"></a>1.4.1  在线抠图</h3><p><a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a> </p><p><a href="https://www.gaoding.com/koutu?hmsr=zhongcao-kt_zh_2023-koutu---sy2023-bdqd&amp;utm_medium=&amp;utm_source=zhongcao">https://www.gaoding.com/koutu?hmsr=zhongcao-kt_zh_2023-koutu---sy2023-bdqd&amp;utm_medium=&amp;utm_source=zhongcao</a> </p><h3 id="1-4-2-可视化"><a href="#1-4-2-可视化" class="headerlink" title="1.4.2  可视化"></a>1.4.2  可视化</h3><p><a href="https://flourish.studio/">https://flourish.studio/</a> </p><h3 id="1-4-3-图片转文字"><a href="#1-4-3-图片转文字" class="headerlink" title="1.4.3  图片转文字"></a>1.4.3  图片转文字</h3><p>百度大脑：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://ai.baidu.com/tech/ocr_others/webimage?track=cp:ainsem|pf:pc|pp:chanpin-wenzishibie|pu:wenzishibie-tupian|ci:|kw:10003289</span><br></pre></td></tr></table></figure><h1 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2.  技巧"></a>2.  技巧</h1><p><a href="https://www.bilibili.com/video/BV1x4411p7LV?p=2">https://www.bilibili.com/video/BV1x4411p7LV?p=2</a></p><p>字体，形状，图片，排版，配色 ，动画ppt</p><p>before/after</p><h2 id="2-1-快捷键"><a href="#2-1-快捷键" class="headerlink" title="2.1  快捷键"></a>2.1  快捷键</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + m 新建幻灯片</span><br><span class="line">或者回车键</span><br></pre></td></tr></table></figure><h2 id="2-2-多个单元格对齐"><a href="#2-2-多个单元格对齐" class="headerlink" title="2.2  多个单元格对齐"></a>2.2  多个单元格对齐</h2><p><a href="https://jingyan.baidu.com/article/5d368d1e24c4657f60c057ae.html">https://jingyan.baidu.com/article/5d368d1e24c4657f60c057ae.html</a></p><p>选中之后，</p><p><img src="/ppt1" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> ppt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（十三）</title>
      <link href="/2022/06/18/code/java/basic_java13/"/>
      <url>/2022/06/18/code/java/basic_java13/</url>
      
        <content type="html"><![CDATA[<h1 id="13-加密与安全"><a href="#13-加密与安全" class="headerlink" title="13.  加密与安全"></a>13.  加密与安全</h1><h2 id="13-1-编码算法"><a href="#13-1-编码算法" class="headerlink" title="13.1  编码算法"></a>13.1  编码算法</h2><h3 id="13-1-1-url编码"><a href="#13-1-1-url编码" class="headerlink" title="13.1.1  url编码"></a>13.1.1  url编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> URLDecoder.decode(encoded);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-1-2-Base64编码"><a href="#13-1-2-Base64编码" class="headerlink" title="13.1.2  Base64编码"></a>13.1.2  Base64编码</h3><p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; (<span class="type">byte</span>) <span class="number">0xe4</span>, (<span class="type">byte</span>) <span class="number">0xb8</span>, (<span class="type">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded); <span class="comment">// 5Lit</span></span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-1-3-哈希算法"><a href="#13-1-3-哈希算法" class="headerlink" title="13.1.3  哈希算法"></a>13.1.3  哈希算法</h3><h4 id="13-1-3-1-md5"><a href="#13-1-3-1-md5" class="headerlink" title="13.1.3.1  md5"></a>13.1.3.1  md5</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-1-3-2-sha1"><a href="#13-1-3-2-sha1" class="headerlink" title="13.1.3.2  sha1"></a>13.1.3.2  sha1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-1-3-3-BouncyCastle"><a href="#13-1-3-3-BouncyCastle" class="headerlink" title="13.1.3.3  BouncyCastle"></a>13.1.3.3  BouncyCastle</h4><h4 id="13-1-3-4-Hmac算法"><a href="#13-1-3-4-Hmac算法" class="headerlink" title="13.1.3.4  Hmac算法"></a>13.1.3.4  Hmac算法</h4><p>常用的对称加密算法有：</p><table><thead><tr><th>算法</th><th>密钥长度</th><th>工作模式</th><th>填充模式</th></tr></thead><tbody><tr><td>DES</td><td>56/64</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/…</td></tr><tr><td>AES</td><td>128/192/256</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td>IDEA</td><td>128</td><td>ECB</td><td>PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><h4 id="13-1-3-5-对称加密算法"><a href="#13-1-3-5-对称加密算法" class="headerlink" title="13.1.3.5  对称加密算法"></a>13.1.3.5  对称加密算法</h4><h5 id="13-1-3-5-1-aes加解密"><a href="#13-1-3-5-1-aes加解密" class="headerlink" title="13.1.3.5.1  aes加解密"></a>13.1.3.5.1  aes加解密</h5><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="type">byte</span>[] key = <span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message: Hello, world!</span><br><span class="line">Encrypted: 2xiGROlFBhC57b7EGu5c3g==</span><br><span class="line">Decrypted: Hello, world!</span><br></pre></td></tr></table></figure><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="type">byte</span>[] key = <span class="string">&quot;1234567890abcdef1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="type">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="type">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] key, <span class="type">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>); <span class="comment">// 从0到第16位之间的数值copy到iv目标数组中，在目标数组的第0位开始位置</span></span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] join(<span class="type">byte</span>[] bs1, <span class="type">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="type">byte</span>[] r = <span class="keyword">new</span> <span class="title class_">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（十二）</title>
      <link href="/2022/06/18/code/java/basic_java12/"/>
      <url>/2022/06/18/code/java/basic_java12/</url>
      
        <content type="html"><![CDATA[<h1 id="12-正则表达式"><a href="#12-正则表达式" class="headerlink" title="12.  正则表达式"></a>12.  正则表达式</h1><p>Java标准库的<code>java.util.regex</code>包内置了正则表达式引擎</p><h2 id="12-1-正则表达式简介"><a href="#12-1-正则表达式简介" class="headerlink" title="12.1  正则表达式简介"></a>12.1  正则表达式简介</h2><p>demo1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2019&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2100&quot;</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">re2</span> <span class="operator">=</span> <span class="string">&quot;a\\&amp;c&quot;</span>; <span class="comment">// 对应的正则是a\&amp;c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;c&quot;</span>.matches(re2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a-c&quot;</span>.matches(re2)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;&amp;c&quot;</span>.matches(re2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-匹配规则"><a href="#12-2-匹配规则" class="headerlink" title="12.2  匹配规则"></a>12.2  匹配规则</h2><p><strong>练习：</strong>测试字符串是否是一个有效的”3<del>4位区号-6</del>8位电话”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tel</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidTel</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;3,4&#125;\\-\\d&#123;6,8&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（十一）</title>
      <link href="/2022/06/18/code/java/basic_java11/"/>
      <url>/2022/06/18/code/java/basic_java11/</url>
      
        <content type="html"><![CDATA[<h1 id="11-单元测试"><a href="#11-单元测试" class="headerlink" title="11.  单元测试"></a>11.  单元测试</h1><p>Java平台最常用的测试框架JUnit</p><h2 id="11-1-编写JUnit测试"><a href="#11-1-编写JUnit测试" class="headerlink" title="11.1  编写JUnit测试"></a>11.1  编写JUnit测试</h2><p>单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（十）</title>
      <link href="/2022/06/18/code/java/basic_java10/"/>
      <url>/2022/06/18/code/java/basic_java10/</url>
      
        <content type="html"><![CDATA[<h1 id="10-日期与时间"><a href="#10-日期与时间" class="headerlink" title="10.  日期与时间"></a>10.  日期与时间</h1>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（九）</title>
      <link href="/2022/06/18/code/java/basic_java9/"/>
      <url>/2022/06/18/code/java/basic_java9/</url>
      
        <content type="html"><![CDATA[<h1 id="9-io"><a href="#9-io" class="headerlink" title="9.  io"></a>9.  io</h1><p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>/<code>Writer</code>。</li></ul><h2 id="9-1-File对象"><a href="#9-1-File对象" class="headerlink" title="9.1  File对象"></a>9.1  File对象</h2><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><p><strong>练习：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">        printFile(path, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFile</span><span class="params">(File dir, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 创建一个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            sp.append(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sp + dir.getName() + (dir.isDirectory() ? <span class="string">&quot;/&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="comment">//列出目录下的文件和子目录名</span></span><br><span class="line">        File[] fs = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : fs) &#123;</span><br><span class="line">                printFile(f, level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-InputStream"><a href="#9-2-InputStream" class="headerlink" title="9.2  InputStream"></a>9.2  InputStream</h2><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举个测试例子：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> readAsString(input);</span><br><span class="line">            System.out.println(s); <span class="comment">// hello</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭</p><h2 id="9-3-OuputStream"><a href="#9-3-OuputStream" class="headerlink" title="9.3  OuputStream"></a>9.3  OuputStream</h2><p><strong>OutputStream实现类</strong></p><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中</p><p>模拟一个<code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><p><strong>练习：</strong></p><p>请利用<code>InputStream</code>和<code>OutputStream</code>，编写一个复制文件的程序，它可以带参数运行：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java CopyFile.java source.txt <span class="built_in">copy</span>.txt</span><br></pre></td></tr></table></figure><p>我在java1.8和java1.1下都运行了以下代码，会出现报错（好像java9、java15可以）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java: 找不到符号</span><br><span class="line">  符号:   方法 transferTo(java.io.OutputStream)</span><br><span class="line">  位置: 类型为java.io.InputStream的变量 input</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage:\n  java CopyFile.java &lt;source&gt; &lt;target&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        copy(args[<span class="number">0</span>], args[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String source, String target)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 友情提示：测试时请使用无关紧要的文件</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(target))</span><br><span class="line">        &#123;</span><br><span class="line">            input.transferTo(output);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-Filter模式"><a href="#9-4-Filter模式" class="headerlink" title="9.4  Filter模式"></a>9.4  Filter模式</h2><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p><ul><li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><p><strong>练习：</strong>编写一个<code>CountInputStream</code>，作用是对输入的字节进行计数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CountInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data))) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBytesRead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-5-操作Zip"><a href="#9-5-操作Zip" class="headerlink" title="9.5  操作Zip"></a>9.5  操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容</p><p><strong>练习：</strong></p><p>输出指定压缩包内文件的文件名和文件内容，将特定字符串写入指定文件名的文件，并将该文件压缩进压缩包，并覆盖掉原压缩包的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;./demo1/1.java/src/main/java/hello.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取zip文件内容</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ZipInputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source))) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//在创建ByteArrayOutputStream类实例时，内存中会创建一个byte数组类型的缓冲区，缓冲区会随着数据的不断写入而自动增长</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="literal">null</span>) &#123; <span class="comment">// null zip结束， 解压 压缩包中的每个文件</span></span><br><span class="line">                Systjjem.out.println(<span class="string">&quot;文件名： &quot;</span> + entry.toString() + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;内容： ----------------------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">                    <span class="type">int</span> n;</span><br><span class="line">                    <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println((<span class="type">char</span>) n);</span><br><span class="line">                        data.write(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(data.toByteArray(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把文件压缩到zip包中去 - 写入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ZipOutputStream</span> <span class="variable">zip2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(source))) &#123;</span><br><span class="line">            <span class="comment">// 新建一个写入的文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">wpath</span> <span class="operator">=</span> <span class="string">&quot;./test.txt&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">wfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(wpath)) &#123;</span><br><span class="line">                wfile.write(<span class="string">&quot;写入压缩包文件0 NAME LUCK JOB TEST&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入压缩包</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(wpath);</span><br><span class="line">            zip2.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(f.getName())); <span class="comment">// 指定要放入的文件名</span></span><br><span class="line">            zip2.write(getFileDataAsBytes(f)); <span class="comment">// 写入该文件的子字节流， 直接把以前的压缩文件内容干掉了</span></span><br><span class="line">            zip2.closeEntry(); <span class="comment">// 关闭文档 ，try(...) 只处理了file.close()</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] getFileDataAsBytes(File f) <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f); <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(n);</span><br><span class="line">            &#125;</span><br><span class="line">            data = out.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-6-读取classpath资源"><a href="#9-6-读取classpath资源" class="headerlink" title="9.6  读取classpath资源"></a>9.6  读取classpath资源</h2><h2 id="9-7-序列化"><a href="#9-7-序列化" class="headerlink" title="9.7  序列化"></a>9.7  序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以变回Java对象，或者从网络上读取<code>byte[]</code>并把它变回Java对象。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为”标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个”标记”，并没有增加任何方法。</p><p><strong>序列化</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">        <span class="comment">// [-84, -19, 0, 5, 119, 11, 0, 0, 48, 57, 0, 5, 72, 101, 108, 108, 111, 115, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 68, 111, 117, 98, 108, 101, -128, -77, -62, 74, 41, 107, -5, 4, 2, 0, 1, 68, 0, 5, 118, 97, 108, 117, 101, 120, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 78, 117, 109, 98, 101, 114, -122, -84, -107, 29, 11, -108, -32, -117, 2, 0, 0, 120, 112, 64, 94, -35, 47, 26, -97, -66, 119]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><p><strong>反序列化</strong></p><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><p><strong>安全性</strong></p><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><p><strong>练习：</strong>写一个序列化和反序列化的demo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            os.writeInt(<span class="number">12345</span>);</span><br><span class="line">            os.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            os.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bufferin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(buffer.toByteArray());</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bufferin))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">            <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> (Double)(in.readObject());</span><br><span class="line">            System.out.println(n);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-8-Reader"><a href="#9-8-Reader" class="headerlink" title="9.8  Reader"></a>9.8  Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><table><thead><tr><th>InputStream</th><th>Reader</th></tr></thead><tbody><tr><td>字节流，以<code>byte</code>为单位</td><td>字符流，以<code>char</code>为单位</td></tr><tr><td>读取字节（-1，0~255）：<code>int read()</code></td><td>读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td>读到字节数组：<code>int read(byte[] b)</code></td><td>读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~`65535<code>。如果已读到末尾，返回</code>-1`。</p><h2 id="9-9-Writer"><a href="#9-9-Writer" class="headerlink" title="9.9  Writer"></a>9.9  Writer</h2><h2 id="9-10-PrintStream和PrintWriter"><a href="#9-10-PrintStream和PrintWriter" class="headerlink" title="9.10  PrintStream和PrintWriter"></a>9.10  PrintStream和PrintWriter</h2><h2 id="9-11-使用Files"><a href="#9-11-使用Files" class="headerlink" title="9.11  使用Files"></a>9.11  使用Files</h2>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（八）</title>
      <link href="/2022/06/18/code/java/basic_java8/"/>
      <url>/2022/06/18/code/java/basic_java8/</url>
      
        <content type="html"><![CDATA[<h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8.  集合"></a>8.  集合</h1><h2 id="8-1-java集合简介"><a href="#8-1-java集合简介" class="headerlink" title="8.1  java集合简介"></a>8.1  java集合简介</h2><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p><ul><li>数组初始化后大小不可变；</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表；</li><li>保证无重复元素的集合；</li><li>…</li></ul><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h2 id="8-2-使用List"><a href="#8-2-使用List" class="headerlink" title="8.2  使用List"></a>8.2  使用List</h2><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 使用了泛型</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 允许重复添加元素，size=3</span></span><br><span class="line">        list.add(<span class="literal">null</span>); <span class="comment">// 允许添加null值</span></span><br><span class="line"><span class="comment">//        System.out.println(list.size()); // 4</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;  <span class="comment">// 遍历</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造从start到end的序列：</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌算法shuffle可以随机交换List中的元素位置:</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 随机删除List中的一个元素:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> list.remove((<span class="type">int</span>) (Math.random() * list.size()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">found</span> <span class="operator">=</span> findMissingNumber(start, end, list);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;missing number: &quot;</span> + found);</span><br><span class="line">        System.out.println(removed == found ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMissingNumber</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> end;</span><br><span class="line">        List&lt;Integer&gt; handler = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list); <span class="comment">// 相当于COPY一份 ~</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer: list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handler.remove(Integer.valueOf(start))) &#123; </span><br><span class="line">                <span class="comment">// 如果不使用中间操作变量，操作 remove 会导致原来的 list 循环出错</span></span><br><span class="line">                <span class="comment">// Integer.valueOf()可以将基本类型int转换为包装类型Integer，或者将String转换成Integer，String如果为Null或&quot;&quot;都会报错</span></span><br><span class="line">                result = start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-编写equals方法"><a href="#8-3-编写equals方法" class="headerlink" title="8.3  编写equals方法"></a>8.3  编写equals方法</h2><p><code>List</code>是一种有序链表：<code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;C&quot;</span>)); <span class="comment">// true，判断List是否包含某个指定元素</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;X&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 2，返回某个元素的索引</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;X&quot;</span>)); <span class="comment">// -1，元素不存在返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给Person类增加equals方法，使得调用indexOf()方法返回正常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao&quot;</span>, <span class="string">&quot;Ming&quot;</span>, <span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao&quot;</span>, <span class="string">&quot;Hong&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> list.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(exist ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="built_in">this</span>.firstName, p.firstName) &amp;&amp; Objects.equals(<span class="built_in">this</span>.lastName, p.lastName) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-使用Map"><a href="#8-4-使用Map" class="headerlink" title="8.4  使用Map"></a>8.4  使用Map</h2><p>用<code>Map</code>来实现根据<code>name</code>查询某个<code>Student</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">target</span> <span class="operator">=</span> map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">another</span> <span class="operator">=</span> map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p><p><strong>遍历map：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p><p>使用<code>Map</code>时，任何依赖顺序的逻辑都是<strong>不可靠</strong>的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><p>请编写一个根据<code>name</code>查找<code>score</code>的程序，并利用<code>Map</code>充当缓存，以提高查找效率：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; list = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">78</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Brush&quot;</span>, <span class="number">66</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Newton&quot;</span>, <span class="number">99</span>));</span><br><span class="line">        <span class="type">Students</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Students</span>(list);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Bob&quot;</span>) == <span class="number">78</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Alice&quot;</span>) == <span class="number">85</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">        System.out.println(holder.getScore(<span class="string">&quot;Tom&quot;</span>) == -<span class="number">1</span> ? <span class="string">&quot;测试成功!&quot;</span> : <span class="string">&quot;测试失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    Student(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Students</span> &#123;</span><br><span class="line">    List&lt;Student&gt; list;<span class="comment">//定义了一个Student的List,名为list,可能十分巨大</span></span><br><span class="line">    Map&lt;String, Integer&gt; cache;<span class="comment">//定义了一个Map,key为String类型，value为Integer类型</span></span><br><span class="line">    <span class="comment">//作为缓存来存放那些被查询频率很高的学生，比如成绩差爱惹事的学生，下次查询直接从这里面找就会很快</span></span><br><span class="line"></span><br><span class="line">    Students(List&lt;Student&gt; list) &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// a.有个娃犯事了，先看看重点关注对象(cache)里有没有这娃</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(name);<span class="comment">//试图从cache中查找这娃对应的成绩</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;<span class="comment">//b.如果成绩为null，说明没有重点关注他(cache里没有他的名字)</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            score = findInList(name);<span class="comment">//c.我们再在学校的超级学生名册里来查找一下</span></span><br><span class="line">            <span class="keyword">if</span> (score!= <span class="literal">null</span>) &#123;<span class="comment">//d.如果有成绩记录，score不为null，看来确实是我们学校的学生</span></span><br><span class="line">                cache.put(name, score);<span class="comment">//e.立即把他放到重点关注对象里来，下次犯事了很快就能查到他所有信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">score</span> <span class="operator">=</span>= <span class="literal">null</span> ? -<span class="number">1</span> : score.intValue();<span class="comment">//f.这里不太好理解，为什么会再次判断score是否为null,我们来分析一下：</span></span><br><span class="line">        <span class="comment">//这里有两种情况：</span></span><br><span class="line">        <span class="comment">//1.当在执行步骤b的判断时如果score!=null，说明重点关注对象里有他，直接跳过if循环，return时score==null为假，返回他的成绩</span></span><br><span class="line">        <span class="comment">//2.当在执行步骤b的判断时如果score==null，if循环里的程序会被执行，这里步骤c的语句 score = findInList(name)会重新对score进行赋值</span></span><br><span class="line">        <span class="comment">//根据下面findInList(String name)方法我们知道它可能返回null,也可能返回分数，所以最后return的时候会再次判断score是否为null</span></span><br><span class="line">        <span class="comment">//如果score为null则返回-1，表示这个学生不在超级学生名单里，不是学校里的娃</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer <span class="title function_">findInList</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Student ss : <span class="built_in">this</span>.list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss.name.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ss.score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//表示查询的人不在名单内</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（七）</title>
      <link href="/2022/06/18/code/java/basic_java7/"/>
      <url>/2022/06/18/code/java/basic_java7/</url>
      
        <content type="html"><![CDATA[<h1 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7.  泛型"></a>7.  泛型</h1><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p><h2 id="7-1-什么是泛型"><a href="#7-1-什么是泛型" class="headerlink" title="7.1  什么是泛型"></a>7.1  什么是泛型</h2><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h2 id="7-2-使用泛型"><a href="#7-2-使用泛型" class="headerlink" title="7.2  使用泛型"></a>7.2  使用泛型</h2><h2 id="7-3-编写泛型"><a href="#7-3-编写泛型" class="headerlink" title="7.3  编写泛型"></a>7.3  编写泛型</h2><h2 id="7-4-擦拭法"><a href="#7-4-擦拭法" class="headerlink" title="7.4  擦拭法"></a>7.4  擦拭法</h2><h2 id="7-5-extends通配符"><a href="#7-5-extends通配符" class="headerlink" title="7.5  extends通配符"></a>7.5  extends通配符</h2><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h2 id="7-6-super通配符"><a href="#7-6-super通配符" class="headerlink" title="7.6  super通配符"></a>7.6  super通配符</h2><h2 id="7-7-泛型和反射"><a href="#7-7-泛型和反射" class="headerlink" title="7.7  泛型和反射"></a>7.7  泛型和反射</h2><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（六）</title>
      <link href="/2022/06/18/code/java/basic_java6/"/>
      <url>/2022/06/18/code/java/basic_java6/</url>
      
        <content type="html"><![CDATA[<h1 id="6-注解"><a href="#6-注解" class="headerlink" title="6.  注解"></a>6.  注解</h1><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p><p>Java的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><h2 id="6-1-使用注解"><a href="#6-1-使用注解" class="headerlink" title="6.1  使用注解"></a>6.1  使用注解</h2><p>注解（Annotation）是Java语言用于工具处理的标注：</p><p>注解可以配置参数，没有指定配置的参数使用默认值；</p><h2 id="6-2-定义注解"><a href="#6-2-定义注解" class="headerlink" title="6.2  定义注解"></a>6.2  定义注解</h2><h2 id="6-3-处理注解"><a href="#6-3-处理注解" class="headerlink" title="6.3  处理注解"></a>6.3  处理注解</h2>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（五）</title>
      <link href="/2022/06/18/code/java/basic_java5/"/>
      <url>/2022/06/18/code/java/basic_java5/</url>
      
        <content type="html"><![CDATA[<h1 id="5-反射"><a href="#5-反射" class="headerlink" title="5.  反射"></a>5.  反射</h1><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例。</p><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="5-1-Class类"><a href="#5-1-Class类" class="headerlink" title="5.1  Class类"></a>5.1  Class类</h2><h3 id="5-1-1-Class实例"><a href="#5-1-1-Class实例" class="headerlink" title="5.1.1  Class实例"></a>5.1.1  Class实例</h3><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p><p><strong>方法一：</strong>直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong>如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">sameClass</span> <span class="operator">=</span> cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class name: java.lang.String</span><br><span class="line">Simple name: String</span><br><span class="line">Package name: java.lang</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: false</span><br><span class="line">is primitive: false</span><br><span class="line">Class name: java.lang.Runnable</span><br><span class="line">Simple name: Runnable</span><br><span class="line">Package name: java.lang</span><br><span class="line">is interface: true</span><br><span class="line">is enum: false</span><br><span class="line">is array: false</span><br><span class="line">is primitive: false</span><br><span class="line">Class name: java.time.Month</span><br><span class="line">Simple name: Month</span><br><span class="line">Package name: java.time</span><br><span class="line">is interface: false</span><br><span class="line">is enum: true</span><br><span class="line">is array: false</span><br><span class="line">is primitive: false</span><br><span class="line">Class name: [Ljava.lang.String;</span><br><span class="line">Simple name: String[]</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: true</span><br><span class="line">is primitive: false</span><br><span class="line">Class name: int</span><br><span class="line">Simple name: int</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: false</span><br><span class="line">is primitive: true</span><br></pre></td></tr></table></figure><h3 id="5-1-2-动态加载"><a href="#5-1-2-动态加载" class="headerlink" title="5.1.2  动态加载"></a>5.1.2  动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p><p>这就是JVM动态加载<code>class</code>的特性。</p><h2 id="5-2-访问字段"><a href="#5-2-访问字段" class="headerlink" title="5.2  访问字段"></a>5.2  访问字段</h2><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><h2 id="5-3-调用方法"><a href="#5-3-调用方法" class="headerlink" title="5.3  调用方法"></a>5.3  调用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h2 id="5-4-调用构造方法"><a href="#5-4-调用构造方法" class="headerlink" title="5.4  调用构造方法"></a>5.4  调用构造方法</h2><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2); <span class="comment">// 456</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-获取继承关系"><a href="#5-5-获取继承关系" class="headerlink" title="5.5  获取继承关系"></a>5.5  获取继承关系</h2><p>当我们获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cls = String.class; // 获取到String的Class</span><br></pre></td></tr></table></figure><p>还可以用实例的<code>getClass()</code>方法获取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;&quot;;</span><br><span class="line">Class cls = s.getClass(); // s是String，因此获取到String的Class</span><br></pre></td></tr></table></figure><p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class s = Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p><h2 id="5-6-动态代理"><a href="#5-6-动态代理" class="headerlink" title="5.6  动态代理"></a>5.6  动态代理</h2><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（四）</title>
      <link href="/2022/06/18/code/java/basic_java4/"/>
      <url>/2022/06/18/code/java/basic_java4/</url>
      
        <content type="html"><![CDATA[<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p><h1 id="4-Maven基础"><a href="#4-Maven基础" class="headerlink" title="4.  Maven基础"></a>4.  Maven基础</h1><p><img src="/basic_java4" alt="maven"></p><h2 id="4-1-Maven介绍"><a href="#4-1-Maven介绍" class="headerlink" title="4.1  Maven介绍"></a>4.1  Maven介绍</h2><p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到<code>commons logging</code>，我们就必须把commons logging的jar包放入classpath。如果我们还需要<code>log4j</code>，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p><p>其次，我们要确定项目的目录结构。例如，<code>src</code>目录存放Java源码，<code>resources</code>目录存放配置文件，<code>bin</code>目录存放编译生成的<code>.class</code>文件。</p><p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p><p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p><p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p><p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p><ul><li>提供了一套标准化的项目结构；</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li><li>提供了一套依赖管理机制。</li></ul><h3 id="4-1-1-Maven项目结构"><a href="#4-1-1-Maven项目结构" class="headerlink" title="4.1.1  Maven项目结构"></a>4.1.1  Maven项目结构</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p><img src="/pic" alt="project"></p><p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p><p>我们再来看最关键的一个项目描述文件<code>pom.xml</code>，它的内容长得像下面：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p><h3 id="4-1-2-安装Maven"><a href="#4-1-2-安装Maven" class="headerlink" title="4.1.2  安装Maven"></a>4.1.2  安装Maven</h3><p><strong>参考资料：</strong></p><p><strong>1、</strong>maven安装与环境配置：<a href="https://blog.csdn.net/u011781521/article/details/52821470">https://blog.csdn.net/u011781521/article/details/52821470</a> </p><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M2_HOME</span><br><span class="line">PATH=%M2_HOME%\bin</span><br></pre></td></tr></table></figure><h2 id="4-2-依赖管理"><a href="#4-2-依赖管理" class="headerlink" title="4.2  依赖管理"></a>4.2  依赖管理</h2><p>Maven解决了依赖管理问题。例如，我们的项目依赖<code>abc</code>这个jar包，而<code>abc</code>又依赖<code>xyz</code>这个jar包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──────────────┐</span><br><span class="line">│Sample Project│</span><br><span class="line">└──────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│     abc      │</span><br><span class="line">└──────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│     xyz      │</span><br><span class="line">└──────────────┘</span><br></pre></td></tr></table></figure><p>当我们声明了<code>abc</code>的依赖时，Maven自动把<code>abc</code>和<code>xyz</code>都加入了我们的项目依赖，不需要我们自己去研究<code>abc</code>是否需要依赖<code>xyz</code>。</p><p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要<code>abc</code>，Maven会自动导入<code>abc</code>的jar包，再判断出<code>abc</code>需要<code>xyz</code>，又会自动导入<code>xyz</code>的jar包，这样，最终我们的项目会依赖<code>abc</code>和<code>xyz</code>两个jar包。</p><h3 id="4-2-1-依赖关系"><a href="#4-2-1-依赖关系" class="headerlink" title="4.2.1  依赖关系"></a>4.2.1  依赖关系</h3><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p><table><thead><tr><th align="left">scope</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">compile</td><td align="left">编译时需要用到该jar包（默认）Maven会把这种类型的依赖直接放入classpath。</td><td align="left">commons-logging</td></tr><tr><td align="left">test</td><td align="left">编译Test时需要用到该jar包，表示仅在测试时使用，正常运行时并不需要。</td><td align="left">junit</td></tr><tr><td align="left">runtime</td><td align="left">编译时不需要，但运行时需要用到</td><td align="left">mysql（JDBC驱动）</td></tr><tr><td align="left">provided</td><td align="left">编译时需要用到，但运行时由JDK或某个服务器提供</td><td align="left">servlet-api</td></tr></tbody></table><p>在pom.xml里，<scope>标签定义了依赖关系。</p><h3 id="4-2-2-唯一ID"><a href="#4-2-2-唯一ID" class="headerlink" title="4.2.2  唯一ID"></a>4.2.2  唯一ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p><ul><li>groupId：属于组织的名称，类似Java的包名；</li><li>artifactId：该jar包自身的名称，类似Java的类名；</li><li>version：该jar包的版本。</li></ul><p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p><p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p><p>注：只有以<code>-SNAPSHOT</code>结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p><h3 id="4-2-3-Maven镜像"><a href="#4-2-3-Maven镜像" class="headerlink" title="4.2.3  Maven镜像"></a>4.2.3  Maven镜像</h3><p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           slow    ┌───────────────────┐</span><br><span class="line">    ┌─────────────&gt;│Maven Central Repo.│</span><br><span class="line">    │              └───────────────────┘</span><br><span class="line">    │                        │</span><br><span class="line">    │                        │sync</span><br><span class="line">    │                        ▼</span><br><span class="line">┌───────┐  fast    ┌───────────────────┐</span><br><span class="line">│ User  │─────────&gt;│Maven Mirror Repo. │</span><br><span class="line">└───────┘          └───────────────────┘</span><br></pre></td></tr></table></figure><p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在apache-maven-3.8.1\conf目录下修改<code>settings.xml</code>配置文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置镜像仓库后，Maven的下载速度就会非常快。</p><h3 id="4-2-4-搜索第三方组件"><a href="#4-2-4-搜索第三方组件" class="headerlink" title="4.2.4  搜索第三方组件"></a>4.2.4  搜索第三方组件</h3><p>最后一个问题：如果我们要引用一个第三方组件，比如<code>okhttp</code>，如何确切地获得它的<code>groupId</code>、<code>artifactId</code>和<code>version</code>？方法是通过<a href="https://search.maven.org/">https://search.maven.org/</a> 搜索关键字，找到对应的组件后，直接复制：</p><p><img src="/pic" alt="dependency"></p><h3 id="4-2-5-命令行编译"><a href="#4-2-5-命令行编译" class="headerlink" title="4.2.5  命令行编译"></a>4.2.5  命令行编译</h3><p>在命令中，进入到<code>pom.xml</code>所在目录，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>如果一切顺利，即可在<code>target</code>目录下获得编译后自动打包的jar。</p><h2 id="4-3-构建流程"><a href="#4-3-构建流程" class="headerlink" title="4.3  构建流程"></a>4.3  构建流程</h2><p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期<code>default</code>为例，它包含以下phase：</p><ul><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>test</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install</li><li>deploy</li></ul><p>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止：</p><ul><li>validate</li><li>…</li><li>package</li></ul><p>如果我们运行<code>mvn compile</code>，Maven也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>，即以下几个phase：</p><ul><li>validate</li><li>…</li><li>compile</li></ul><p>Maven另一个常用的生命周期是<code>clean</code>，它会执行3个phase：</p><ul><li>pre-clean</li><li>clean （注意这个clean不是lifecycle而是phase）</li><li>post-clean</li></ul><p>所以，我们使用<code>mvn</code>这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p><p>更复杂的例子是指定多个phase，例如，运行<code>mvn clean package</code>，Maven先执行<code>clean</code>生命周期并运行到<code>clean</code>这个phase，然后执行<code>default</code>生命周期并运行到<code>package</code>这个phase，实际执行的phase如下：</p><ul><li>pre-clean</li><li>clean （注意这个clean是phase）</li><li>validate</li><li>…</li><li>package</li></ul><p>在实际开发过程中，经常使用的命令有：</p><p><code>mvn clean</code>：清理所有生成的class和jar；</p><p><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</p><p><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</p><p><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</p><p>大多数phase在执行过程中，因为我们通常没有在<code>pom.xml</code>中配置相关的设置，所以这些phase什么事情都不做。</p><p>经常用到的phase其实只有几个：</p><ul><li>clean：清理</li><li>compile：编译</li><li>test：运行测试</li><li>package：打包</li></ul><h2 id="4-4-使用插件（-）"><a href="#4-4-使用插件（-）" class="headerlink" title="4.4  使用插件（!）"></a>4.4  使用插件（!）</h2><p><strong>参考资料：</strong></p><p><strong>1、</strong>maven打包之resource配置：<a href="https://blog.csdn.net/u011781521/article/details/79052725">https://blog.csdn.net/u011781521/article/details/79052725</a> </p><h2 id="4-5-模块管理（-）"><a href="#4-5-模块管理（-）" class="headerlink" title="4.5  模块管理（!）"></a>4.5  模块管理（!）</h2><p><strong>中央仓库：</strong></p><p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p><p>Maven支持模块化管理，可以把一个大项目拆成几个模块：</p><ul><li>可以通过继承在parent的<code>pom.xml</code>统一定义重复配置；</li><li>可以通过<code>&lt;modules&gt;</code>编译多个模块。</li></ul><h2 id="4-6-使用mvnw（-）"><a href="#4-6-使用mvnw（-）" class="headerlink" title="4.6  使用mvnw（!）"></a>4.6  使用mvnw（!）</h2><p><code>mvnw</code>是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p><p>简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。</p><h2 id="4-7-发布Artifact（-）"><a href="#4-7-发布Artifact（-）" class="headerlink" title="4.7  发布Artifact（!）"></a>4.7  发布Artifact（!）</h2><p>发布一个库到Maven的repo中。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（三）</title>
      <link href="/2022/06/18/code/java/basic_java3/"/>
      <url>/2022/06/18/code/java/basic_java3/</url>
      
        <content type="html"><![CDATA[<h1 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.  异常处理"></a>3.  异常处理</h1><h2 id="3-1-Java的异常"><a href="#3-1-Java的异常" class="headerlink" title="3.1  Java的异常"></a>3.1  Java的异常</h2><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">String</span> s = <span class="title function_">processFile</span>(“<span class="attr">C</span>:\\test.<span class="property">txt</span>”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">FileNotFoundException</span> e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">SecurityException</span> e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line"><span class="comment">//        return s.getBytes(&quot;GBK&quot;);</span></span><br><span class="line">        <span class="comment">// java: 未报告的异常错误java.io.UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-捕获异常"><a href="#3-2-捕获异常" class="headerlink" title="3.2  捕获异常"></a>3.2  捕获异常</h2><p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。</p><p>UnsupportedEncodingException是IOException的子类</p><p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</p><p><strong>练习：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;x9&quot;</span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 捕获异常并处理</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> stringToInt(a);</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> stringToInt(b);</span><br><span class="line">System.out.println(c * d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">stringToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="comment">//return Integer.parseInt(s);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bad input&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 记录在栈堆里，就是把报错的堆栈信息展示出来</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1) &#123;</span><br><span class="line">System.out.println(e1);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-抛出异常"><a href="#3-3-抛出异常" class="headerlink" title="3.3  抛出异常"></a>3.3  抛出异常</h2><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p><p><strong>练习：</strong>如果传入的参数为负，则抛出<code>IllegalArgumentException</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(tax(<span class="number">2000</span>, <span class="number">0.1</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(tax(-<span class="number">200</span>, <span class="number">0.1</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(tax(<span class="number">2000</span>, -<span class="number">0.1</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">tax</span><span class="params">(<span class="type">int</span> salary, <span class="type">double</span> rate)</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 如果传入的参数为负，则抛出IllegalArgumentException</span></span><br><span class="line"><span class="keyword">if</span>(salary &lt; <span class="number">0</span> || rate &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不能为负数&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> salary * rate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-自定义异常"><a href="#3-4-自定义异常" class="headerlink" title="3.4  自定义异常"></a>3.4  自定义异常</h2><p>Java标准库定义的常用异常包括：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><p>Main.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;111112&quot;</span>);</span><br><span class="line">System.out.println(token);</span><br><span class="line">&#125;<span class="keyword">catch</span>(UserNotFoundException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;User Not Found!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (PasswordErrorException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Password Error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(password.equals(<span class="string">&quot;111111&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> username+<span class="string">&quot; login successed.&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PasswordErrorException</span>(<span class="string">&quot;Password Error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;User Not Found!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserNotFoundException</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PasswordErrorException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PasswordErrorException</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PasswordErrorException</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseException.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message, cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-NullPointerException"><a href="#3-5-NullPointerException" class="headerlink" title="3.5  NullPointerException"></a>3.5  NullPointerException</h2><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由JVM抛出的，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地说是Null Reference，不过两者区别不大。</p><p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p><h2 id="3-6-使用断言"><a href="#3-6-使用断言" class="headerlink" title="3.6  使用断言"></a>3.6  使用断言</h2><h2 id="3-7-使用JDK-Logging"><a href="#3-7-使用JDK-Logging" class="headerlink" title="3.7  使用JDK Logging"></a>3.7  使用JDK Logging</h2><p>Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p><h2 id="3-8-使用Commons-Logging"><a href="#3-8-使用Commons-Logging" class="headerlink" title="3.8  使用Commons Logging"></a>3.8  使用Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Logging自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p><p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； 第二步，使用<code>Log</code>实例的方法打日志。</p><p>示例代码如下：</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（二）</title>
      <link href="/2022/06/18/code/java/basic_java2/"/>
      <url>/2022/06/18/code/java/basic_java2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="2.  面向对象编程"></a>2.  面向对象编程</h1><p>class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型</p><p>而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同</p><h2 id="2-1-面向对象基础"><a href="#2-1-面向对象基础" class="headerlink" title="2.1  面向对象基础"></a>2.1  面向对象基础</h2><h3 id="2-1-1-方法"><a href="#2-1-1-方法" class="headerlink" title="2.1.1  方法"></a>2.1.1  方法</h3><p>方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；</p><h3 id="2-1-2-方法重载"><a href="#2-1-2-方法重载" class="headerlink" title="2.1.2  方法重载"></a>2.1.2  方法重载</h3><h3 id="2-1-3-继承"><a href="#2-1-3-继承" class="headerlink" title="2.1.3  继承"></a>2.1.3  继承</h3><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p><h3 id="2-1-4-多态"><a href="#2-1-4-多态" class="headerlink" title="2.1.4  多态"></a>2.1.4  多态</h3><h4 id="2-1-4-1-覆写"><a href="#2-1-4-1-覆写" class="headerlink" title="2.1.4.1  覆写"></a>2.1.4.1  覆写</h4><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）</p><p>方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符。</p><p>在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Override和Overload不同的是，方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>（加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错）。</p><h4 id="2-1-4-2-多态"><a href="#2-1-4-2-多态" class="headerlink" title="2.1.4.2  多态"></a>2.1.4.2  多态</h4><p>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h3 id="2-1-5-抽象类"><a href="#2-1-5-抽象类" class="headerlink" title="2.1.5  抽象类"></a>2.1.5  抽象类</h3><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>abstract</code>修饰的类就是抽象类，我们无法实例化一个抽象类。</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法。</p><p><strong>练习：</strong>用抽象类给一个有工资收入和稿费收入的小伙伴算税。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Income[] incomes = <span class="keyword">new</span> <span class="title class_">Income</span>[] &#123; <span class="keyword">new</span> <span class="title class_">SalaryIncome</span>(<span class="number">7500</span>), <span class="keyword">new</span> <span class="title class_">RoyaltyIncome</span>(<span class="number">12000</span>) &#125;;</span><br><span class="line"><span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Income income:incomes) &#123;</span><br><span class="line">total += income.getTax();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(total);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Income</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Income</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.income = income;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryIncome</span> <span class="keyword">extends</span> <span class="title class_">Income</span>&#123; <span class="comment">// SalaryIncome是Income类的子类，工资收入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SalaryIncome</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(income);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.income &lt;= <span class="number">5000</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span>.income-<span class="number">5000</span>)*<span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoyaltyIncome</span> <span class="keyword">extends</span> <span class="title class_">Income</span>&#123; <span class="comment">// RoyaltyIncome是Income类的子类，稿费收入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RoyaltyIncome</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(income);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.income*<span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-6-接口"><a href="#2-1-6-接口" class="headerlink" title="2.1.6  接口"></a>2.1.6  接口</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而<strong>保证所有子类都有相同的接口实现</strong>，这样，多态就能发挥出威力。</p><p><strong>练习：</strong>用接口给一个有工资收入和稿费收入的小伙伴算税。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Income[] incomes = <span class="keyword">new</span> <span class="title class_">Income</span>[] &#123; <span class="keyword">new</span> <span class="title class_">SalaryIncome</span>(<span class="number">7500</span>), <span class="keyword">new</span> <span class="title class_">RoyaltyIncome</span>(<span class="number">12000</span>) &#125;;</span><br><span class="line"><span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Income in:incomes) &#123;</span><br><span class="line">total += in.getTax();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(total);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 稿费收入税率是20%</span></span><br><span class="line"><span class="comment"> * 放到同文件夹下的Income.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Income</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 稿费收入税率是20%</span></span><br><span class="line"><span class="comment"> * 放到同文件夹下的RoyaltyIncome.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoyaltyIncome</span> <span class="keyword">implements</span> <span class="title class_">Income</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RoyaltyIncome</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.income = income;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span>.income * <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工资收入超过5000部分的税率是20%</span></span><br><span class="line"><span class="comment"> * 放到同文件夹下的SalaryIncome.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryIncome</span> <span class="keyword">implements</span> <span class="title class_">Income</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SalaryIncome</span><span class="params">(<span class="type">double</span> income)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.income = income;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (income - <span class="number">5000</span>)*<span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-7-静态字段和静态方法"><a href="#2-1-7-静态字段和静态方法" class="headerlink" title="2.1.7  静态字段和静态方法"></a>2.1.7  静态字段和静态方法</h3><h4 id="2-1-7-1-静态字段"><a href="#2-1-7-1-静态字段" class="headerlink" title="2.1.7.1  静态字段"></a>2.1.7.1  静态字段</h4><p>所有实例共享一个静态字段。</p><p>推荐用类名来访问静态字段，可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。</p><p><strong>接口的静态字段：</strong></p><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-7-2-静态方法"><a href="#2-1-7-2-静态方法" class="headerlink" title="2.1.7.2   静态方法"></a>2.1.7.2   静态方法</h4><p>调用实例方法必须通过一个实例变量，而不能直接通过类来调用。</p><h3 id="2-1-8-包"><a href="#2-1-8-包" class="headerlink" title="2.1.8  包"></a>2.1.8  包</h3><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p><p>注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p><p><strong>练习：</strong>请按如下包结构创建工程项目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-package</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p><p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p><p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p><p>包名推荐使用倒置的域名，例如<code>org.apache</code>。</p><h3 id="2-1-9-作用域"><a href="#2-1-9-作用域" class="headerlink" title="2.1.9  作用域"></a>2.1.9  作用域</h3><p><strong>小结</strong></p><p>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</p><p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p><p><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p><h3 id="2-1-10-内部类"><a href="#2-1-10-内部类" class="headerlink" title="2.1.10  内部类"></a>2.1.10  内部类</h3><h3 id="2-1-11-classpath和jar"><a href="#2-1-11-classpath和jar" class="headerlink" title="2.1.11  classpath和jar"></a>2.1.11  classpath和jar</h3><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p><strong>小结：</strong></p><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p><p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p><p>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p><p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。</p><h3 id="2-1-12-模块"><a href="#2-1-12-模块" class="headerlink" title="2.1.12  模块"></a>2.1.12  模块</h3><p>liaoxuefeng的教程笔记，但jar –create那里出现问题，显示<code>非法选项: -</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">windows下打包JRE步骤：</span><br><span class="line">打开cmd.exe</span><br><span class="line"><span class="number">1.</span> 切换工作目录到oop-<span class="keyword">module</span>，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下：</span><br><span class="line">D:\Program Files\Eclipse\oop-<span class="keyword">module</span>&gt;javac -d bin src/<span class="keyword">module</span>-info.java src/com/itranswarp/sample<span class="comment">/*.java</span></span><br><span class="line"><span class="comment">编译成功，原来空白的bin目录下多了class文件：</span></span><br><span class="line"><span class="comment">src目录下的module-info.java被编译到bin目录下的 module-info.class；</span></span><br><span class="line"><span class="comment">src目录下的com/itranswarp/sample/Main.java 和 Greeting.java 被编译到bin/com/itranswarp/sample目录下的</span></span><br><span class="line"><span class="comment">Main.class 和 Greeting.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 把bin目录下的所有class文件先打包成jar:</span></span><br><span class="line"><span class="comment">D:\Program Files\Eclipse\oop-module&gt;jar --create --file hello.jar --main-class</span></span><br><span class="line"><span class="comment">com.itranswarp.sample.Main -C bin .</span></span><br><span class="line"><span class="comment">(bin后面是空格再加点（.）表示当前目录)</span></span><br><span class="line"><span class="comment">编译成功后，当前目录增加一个hello.jar文件；</span></span><br><span class="line"><span class="comment">可以直接运行：java -jar hello.jar</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 把jar包转换成模块（.jmod）:</span></span><br><span class="line"><span class="comment">D:\Program Files\Eclipse\oop-module&gt;jmod create --class-path hello.jar hello.jmod</span></span><br><span class="line"><span class="comment">编译成功后，当前目录下得到一个hello.jmod模块文件；</span></span><br><span class="line"><span class="comment">可以直接运行：java --module-path hello.jar --module hello.world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 打包JRE，jlink裁剪程序用到的模块</span></span><br><span class="line"><span class="comment">D:\Program Files\Eclipse\oop-module&gt;jlink --module-path hello.jmod --add-modules</span></span><br><span class="line"><span class="comment">java.base,java.xml,hello.world --output jre/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 切换到jre目录，运行JRE</span></span><br><span class="line"><span class="comment">D:\Program Files\Eclipse\oop-module\jre\bin&gt;java --module hello.world</span></span><br></pre></td></tr></table></figure><p>参考下别的文章：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -cvf Main.jar *.class</span><br></pre></td></tr></table></figure><h2 id="2-2-Java核心类"><a href="#2-2-Java核心类" class="headerlink" title="2.2  Java核心类"></a>2.2  Java核心类</h2><h3 id="2-2-1-字符串和编码"><a href="#2-2-1-字符串和编码" class="headerlink" title="2.2.1  字符串和编码"></a>2.2.1  字符串和编码</h3><h4 id="2-2-1-1-字符串"><a href="#2-2-1-1-字符串" class="headerlink" title="2.2.1.1  字符串"></a>2.2.1.1  字符串</h4><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s2 = new String(new char[] &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;!&#x27;&#125;);</span><br></pre></td></tr></table></figure><p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><p>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p><h4 id="2-2-1-2-base64编码"><a href="#2-2-1-2-base64编码" class="headerlink" title="2.2.1.2  base64编码"></a>2.2.1.2  base64编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello Base64 啊啊\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;ADCDEFG&quot;</span>;</span><br><span class="line">        <span class="comment">//编码加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodeStr</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;加密后的字符串为:&quot;</span> + encodeStr);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//解码解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decoderStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(encodeStr), StandardCharsets.UTF_8); <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 推荐使用StandardCharsets类指定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解密后的字符串为&quot;</span> + decoderStr);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-StringBuilder"><a href="#2-2-2-StringBuilder" class="headerlink" title="2.2.2  StringBuilder"></a>2.2.2  StringBuilder</h3><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><p><strong>练习：生成sql的插入语句</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] fields = &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;position&quot;</span>, <span class="string">&quot;salary&quot;</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;employee&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> buildInsertSql(table, fields);</span><br><span class="line">        System.out.println(insert);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">buildInsertSql</span><span class="params">(String table, String[] fields)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">insertValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">insertFields</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s:fields) &#123;</span><br><span class="line">            insertFields.append(s).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            insertValues.append(<span class="string">&quot;?, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        insertFields.delete(insertFields.length()-<span class="number">2</span>, insertFields.length());</span><br><span class="line">        insertValues.delete(insertValues.length()-<span class="number">2</span>, insertValues.length());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;INSERT INTO &quot;</span> + table + <span class="string">&quot; (&quot;</span> + insertFields + <span class="string">&quot;)&quot;</span> + <span class="string">&quot; VALUES &quot;</span> + <span class="string">&quot;(&quot;</span> + insertValues + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-StringJoiner（字符串拼接）"><a href="#2-2-3-StringJoiner（字符串拼接）" class="headerlink" title="2.2.3  StringJoiner（字符串拼接）"></a>2.2.3  StringJoiner（字符串拼接）</h3><p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>); </span><br><span class="line">        <span class="comment">// 指定了连接符，开头，结尾</span></span><br><span class="line">        <span class="comment">// StringJoiner在java10版本之后可以改成var</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String.join()</strong></p><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h3 id="2-2-4-包装类型"><a href="#2-2-4-包装类型" class="headerlink" title="2.2.4  包装类型"></a>2.2.4  包装类型</h3><p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p><h3 id="2-2-5-JavaBean"><a href="#2-2-5-JavaBean" class="headerlink" title="2.2.5  JavaBean"></a>2.2.5  JavaBean</h3><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性，属性是一种通用的叫法，并非Java语法规定；</p><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class); <span class="comment">// 获取属性列表</span></span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age</span><br><span class="line">  public int Person.getAge()</span><br><span class="line">  public void Person.setAge(int)</span><br><span class="line">class</span><br><span class="line">  public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">  null</span><br><span class="line">name</span><br><span class="line">  public java.lang.String Person.getName()</span><br><span class="line">  public void Person.setName(java.lang.String)</span><br></pre></td></tr></table></figure><p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。</p><h3 id="2-2-6-枚举类（-）"><a href="#2-2-6-枚举类（-）" class="headerlink" title="2.2.6  枚举类（!）"></a>2.2.6  枚举类（!）</h3><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.WED;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON:</span><br><span class="line">            <span class="keyword">case</span> TUE:</span><br><span class="line">            <span class="keyword">case</span> WED:</span><br><span class="line">            <span class="keyword">case</span> THU:</span><br><span class="line">            <span class="keyword">case</span> FRI:</span><br><span class="line">                System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SAT:</span><br><span class="line">            <span class="keyword">case</span> SUN:</span><br><span class="line">                System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-记录类（-）"><a href="#2-2-7-记录类（-）" class="headerlink" title="2.2.7  记录类（!）"></a>2.2.7  记录类（!）</h3><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h3 id="2-2-8-BigInteger"><a href="#2-2-8-BigInteger" class="headerlink" title="2.2.8  BigInteger"></a>2.2.8  BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigInteger bi = new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000</span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigInteger i1 = new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);</span><br><span class="line">BigInteger sum = i1.add(i2); // 12345678902469135780</span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x10^38），那么返回的float是Infinity。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;999999&quot;</span>).pow(<span class="number">99</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> n.floatValue();</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-9-BigDecimal"><a href="#2-2-9-BigDecimal" class="headerlink" title="2.2.9  BigDecimal"></a>2.2.9  BigDecimal</h3><h3 id="2-2-10-常用工具类"><a href="#2-2-10-常用工具类" class="headerlink" title="2.2.10  常用工具类"></a>2.2.10  常用工具类</h3><p><strong>小结：</strong></p><p>Java提供的常用工具类有：</p><ul><li>Math：数学计算</li><li>Random：生成伪随机数</li><li>SecureRandom：生成安全的随机数</li></ul>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰java教程（一）</title>
      <link href="/2022/06/14/code/java/basic_java1/"/>
      <url>/2022/06/14/code/java/basic_java1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-java快速入门"><a href="#1-java快速入门" class="headerlink" title="1.  java快速入门"></a>1.  java快速入门</h1><p>Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p><p><strong>参考资料：</strong></p><p><strong>1、</strong>vscode java终端输出乱码：<a href="https://blog.csdn.net/weixin_44489823/article/details/104785029">https://blog.csdn.net/weixin_44489823/article/details/104785029</a></p><p><strong>2、</strong>VSCode配置基于java + LeetCode环境：<a href="https://blog.csdn.net/qq_33934427/article/details/105912963">https://blog.csdn.net/qq_33934427/article/details/105912963</a></p><p><strong>3、</strong>liaoxuefeng：<code>git clone git@gitee.com:liaoxuefeng/learn-java.git</code></p><h2 id="1-1-instrument"><a href="#1-1-instrument" class="headerlink" title="1.1  instrument"></a>1.1  instrument</h2><h3 id="1-1-0-安装"><a href="#1-1-0-安装" class="headerlink" title="1.1.0  安装"></a>1.1.0  安装</h3><p>找到javaSE，JDK Download</p><p>设置一个<code>JAVA_HOME</code>的环境变量</p><p>然后，把<code>JAVA_HOME</code>的<code>bin</code>目录附加到系统环境变量<code>PATH</code>上。在Windows下，它长这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path=%JAVA_HOME%\bin;&lt;现有的其他路径&gt;</span><br></pre></td></tr></table></figure><p>bin目录下的可执行文件：</p><ul><li>java：这个可执行程序其实就是JVM（虚拟机），运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li><li>javadoc：用于从Java源码中自动提取注释并生成文档；</li><li>jdb：Java调试器，用于开发阶段的运行调试。</li></ul><h3 id="1-1-1-jd-gui"><a href="#1-1-1-jd-gui" class="headerlink" title="1.1.1  jd-gui"></a>1.1.1  jd-gui</h3><p>资源链接：<a href="https://www.cr173.com/soft/1096707.html">https://www.cr173.com/soft/1096707.html</a></p><p>JD-GUI是一个独立的图形实用程序，显示<code>&quot;.class&quot;</code>文件的Java源代码。 </p><h3 id="1-1-2-jad"><a href="#1-1-2-jad" class="headerlink" title="1.1.2  jad"></a>1.1.2  jad</h3><p><a href="https://varaneckas.com/jad/">https://varaneckas.com/jad/</a></p><p><img src="/2022/06/14/code/java/basic_java1/4.png" alt="1"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jad -o -r -s java -d src demo/**/*.class</span><br></pre></td></tr></table></figure><h2 id="1-2-JAVA语言基础"><a href="#1-2-JAVA语言基础" class="headerlink" title="1.2  JAVA语言基础"></a>1.2  JAVA语言基础</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// void是方法的返回类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个java文件必须含有主函数，在eclipse或其他编译器中，还需要public class命名与文件名一致才可以正确运行JAVA，而IDEA可以自动识别（IDEA牛逼！)</p><h3 id="1-2-1-声明变量"><a href="#1-2-1-声明变量" class="headerlink" title="1.2.1  声明变量"></a>1.2.1  声明变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final double PI = 3.14159;  //声明double型常量PI并赋值</span><br><span class="line">final boolean BOOL = true;  //声明boolean型常量BOOL并赋值</span><br><span class="line"></span><br><span class="line">常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。</span><br></pre></td></tr></table></figure><h3 id="1-2-2-整数-浮点类型"><a href="#1-2-2-整数-浮点类型" class="headerlink" title="1.2.2  整数/浮点类型"></a>1.2.2  整数/浮点类型</h3><table><thead><tr><th align="left">数据类型</th><th align="left">字节</th><th align="left">长度</th><th align="left">取值范围</th></tr></thead><tbody><tr><td align="left">byte(字节)</td><td align="left">1字节</td><td align="left">8位</td><td align="left">-128～127</td></tr><tr><td align="left">short(短整形)</td><td align="left">2字节</td><td align="left">16位</td><td align="left">-32768～32767</td></tr><tr><td align="left">int(整形)</td><td align="left">4字节</td><td align="left">32位</td><td align="left">-2147483648～2147483647</td></tr><tr><td align="left">long(长整型)</td><td align="left">8字节</td><td align="left">64位</td><td align="left">-9223372036854775808～9223372036854775807</td></tr><tr><td align="left">float</td><td align="left">4字节</td><td align="left">32位</td><td align="left">1.4E-45～3.4028235E38</td></tr><tr><td align="left">double</td><td align="left">8字节</td><td align="left">64位</td><td align="left">4.9E-324～1.7976931348623157E308</td></tr></tbody></table><p><strong>注：</strong></p><p><strong>1、</strong>浮点数可表示的范围非常大，<code>float</code>类型可最大表示3.4x(10^38)，而<code>double</code>类型可最大表示1.79x(10^308)。</p><p><strong>2、</strong>使用float需注明，例如：<code>float f1=13.23f</code></p><p><strong>3、</strong>获取变量类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.13f</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="type">char</span> <span class="number">97</span>; <span class="comment">// java.lang.Character類封裝在一個對象的基本類型char值。</span></span><br><span class="line">System.out.println(getType(a));</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Java!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span>&#123; <span class="comment">//获取变量类型方法</span></span><br><span class="line"><span class="keyword">return</span> o.getClass().toString(); <span class="comment">//使用int类型的getClass()方法</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-1-整数"><a href="#1-2-2-1-整数" class="headerlink" title="1.2.2.1  整数"></a>1.2.2.1  整数</h4><p>整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 12345 / 67; // 184</span><br></pre></td></tr></table></figure><p>特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。</p><p>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2147483640</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;</span><br><span class="line">        System.out.println(sum); <span class="comment">// -2147483641</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决上面的问题，可以把<code>int</code>换成<code>long</code>类型，由于<code>long</code>可表示的整型范围更大，所以结果就不会溢出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2147483640</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;</span><br><span class="line">System.out.println(sum); <span class="comment">// 2147483655</span></span><br></pre></td></tr></table></figure><p>超出范围的强制转型会得到错误的结果，原因是转型时，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1234567</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> (<span class="type">short</span>) i1; <span class="comment">// -10617</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">12345678</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>) i2; <span class="comment">// 24910</span></span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-2-浮点数"><a href="#1-2-2-2-浮点数" class="headerlink" title="1.2.2.2  浮点数"></a>1.2.2.2  浮点数</h4><p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p><p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p><p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">9.0</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 观察x和y是否相等:</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0.1</span></span><br><span class="line"><span class="comment">// 0.09999999999999998</span></span><br></pre></td></tr></table></figure><p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较x和y是否相等，先计算其差的绝对值:</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参与运算的两个数其中一个是整型，另一个是浮点型，那么整型可以自动提升到浮点型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24.0</span> / n; <span class="comment">// 6.0</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// 5.2</span></span><br></pre></td></tr></table></figure><p>溢出</p><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code>NaN</code>表示Not a Number</li><li><code>Infinity</code>表示无穷大</li><li><code>-Infinity</code>表示负无穷大</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">12.3</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">12.7</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">int</span>) -<span class="number">12.7</span>; <span class="comment">// -12</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">12.7</span> + <span class="number">0.5</span>); <span class="comment">// 13</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1.2e20</span>; <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure><p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2.6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (d + <span class="number">0.5</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-3-demo"><a href="#1-2-2-3-demo" class="headerlink" title="1.2.2.3  demo"></a>1.2.2.3  demo</h4><h5 id="1-2-2-3-1-编写一个计算BMI指数的JAVA程序"><a href="#1-2-2-3-1-编写一个计算BMI指数的JAVA程序" class="headerlink" title="1.2.2.3.1  编写一个计算BMI指数的JAVA程序"></a>1.2.2.3.1  编写一个计算BMI指数的JAVA程序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BMIexponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1.72</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">exponent</span> <span class="operator">=</span> weight / (height * height);</span><br><span class="line">        System.out.println(<span class="string">&quot;您的身高为&quot;</span>+height);</span><br><span class="line">        System.out.println(<span class="string">&quot;您的体重为&quot;</span>+weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;您的BMI指数为&quot;</span>+exponent);</span><br><span class="line">        System.out.println(<span class="string">&quot;您的体重属于&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">18.5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;体重过轻&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">18.5</span> &amp;&amp; exponent &lt; <span class="number">24.9</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正常范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">24.9</span> &amp;&amp; exponent &lt; <span class="number">29.9</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;体重过重&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt; <span class="number">29.9</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;肥胖&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-3-2-温度单位转换"><a href="#1-2-2-3-2-温度单位转换" class="headerlink" title="1.2.2.3.2  温度单位转换"></a>1.2.2.3.2  温度单位转换</h5><p><code>将37摄氏度转换为整形的华氏度。华氏度=32+摄氏度*1.8</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">fahrenheit</span> <span class="operator">=</span> <span class="number">32</span> + (c * <span class="number">1.8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;摄氏度：&quot;</span> + c + <span class="string">&quot;转化为华氏度为：&quot;</span> + fahrenheit);</span><br><span class="line">        <span class="comment">// 整型可以和字符串拼接在一起吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-3-3-用bool判断用户输入的值"><a href="#1-2-2-3-3-用bool判断用户输入的值" class="headerlink" title="1.2.2.3.3  用bool判断用户输入的值"></a>1.2.2.3.3  用bool判断用户输入的值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loginservice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">passwd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//创建扫描器，获取控制台输入的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">password</span> <span class="operator">=</span> passwd.nextInt(); <span class="comment">//将用户输入的值给password</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (password == <span class="number">123456</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的密码是：&quot;</span> + result + <span class="string">&quot;的&quot;</span>);</span><br><span class="line">        passwd.close(); <span class="comment">//关闭扫描器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-3-4-模拟一个简单的计算器"><a href="#1-2-2-3-4-模拟一个简单的计算器" class="headerlink" title="1.2.2.3.4  模拟一个简单的计算器"></a>1.2.2.3.4  模拟一个简单的计算器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">operator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入两个数字并用空格隔开：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        <span class="comment">// sc.nextDouble();等待输入一个double类型的数值。</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;和&quot;</span> + (num1 + num2));</span><br><span class="line">        System.out.println(<span class="string">&quot;差&quot;</span> + (num1 - num2));</span><br><span class="line">        System.out.println(<span class="string">&quot;商&quot;</span> + (num1 / num2));</span><br><span class="line">        System.out.println(<span class="string">&quot;积&quot;</span> + (num1 * num2));</span><br><span class="line">        System.out.println(<span class="string">&quot;余数&quot;</span> + (num1 % num2));</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-字符和字符串"><a href="#1-2-3-字符和字符串" class="headerlink" title="1.2.3  字符和字符串"></a>1.2.3  字符和字符串</h3><p>在Java中，字符和字符串是两个不同的类型。</p><p>字符类型<code>char</code>是基本数据类型，它是<code>character</code>的缩写，一个<code>char</code>保存一个Unicode字符。</p><p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 字母&quot;A&quot;的Unicodde编码是65</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>; <span class="comment">// 汉字&quot;中&quot;的Unicode编码是20013</span></span><br></pre></td></tr></table></figure><p>还可以直接用转义字符<code>\u</code>+Unicode编码来表示一个字符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>; <span class="comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span></span><br></pre></td></tr></table></figure><p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的不可变是指字符串内容不可变。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> s;</span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(t); <span class="comment">// t是&quot;hello&quot;还是&quot;world&quot;?</span></span><br><span class="line">        <span class="comment">// hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">72</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">105</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">65281</span>;</span><br><span class="line">        String s=<span class="string">&quot;&quot;</span>+(<span class="type">char</span>)a+(<span class="type">char</span>)b+(<span class="type">char</span>)c;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-数组类型"><a href="#1-2-4-数组类型" class="headerlink" title="1.2.4  数组类型"></a>1.2.4  数组类型</h3><p>Java的数组有几个特点：</p><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li></ul><p>初始化数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">形式<span class="number">1</span>：</span><br><span class="line"><span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line"></span><br><span class="line">形式<span class="number">2</span>：</span><br><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line"></span><br><span class="line">形式<span class="number">3</span>：</span><br><span class="line"><span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">ns[<span class="number">0</span>] = <span class="number">68</span>;</span><br><span class="line">    </span><br><span class="line">ns.length</span><br></pre></td></tr></table></figure><h3 id="1-2-5-运算符"><a href="#1-2-5-运算符" class="headerlink" title="1.2.5  运算符"></a>1.2.5  运算符</h3><h4 id="1-2-5-1-位运算符"><a href="#1-2-5-1-位运算符" class="headerlink" title="1.2.5.1  位运算符"></a>1.2.5.1  位运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">与</td></tr><tr><td align="left">｜</td><td align="left">或</td></tr><tr><td align="left">～</td><td align="left">取反</td></tr><tr><td align="left">^</td><td align="left">异或</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移位</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移位</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">无符号右移位</td></tr></tbody></table><hr><h4 id="1-2-5-2-复合赋值运算符"><a href="#1-2-5-2-复合赋值运算符" class="headerlink" title="1.2.5.2  复合赋值运算符"></a>1.2.5.2  复合赋值运算符</h4><p><code>+=</code> </p><p><code>a+=b</code> </p><p><code>a=a+b</code> 其他等同</p><hr><h4 id="1-2-5-3-三元运算符"><a href="#1-2-5-3-三元运算符" class="headerlink" title="1.2.5.3  三元运算符"></a>1.2.5.3  三元运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span> &lt; <span class="number">45</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>即运算结果为真返回ture，为假返回false，等价于if else语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> a;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">20</span> &lt; <span class="number">45</span>)</span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  a = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-2-5-4-运算优先级"><a href="#1-2-5-4-运算优先级" class="headerlink" title="1.2.5.4  运算优先级"></a>1.2.5.4  运算优先级</h4><ol><li><code>()</code></li><li><code>+ -</code> //此为正负号</li><li><code>++ -- !</code></li><li><code>* / %</code></li><li><code>+ -</code></li><li><code>&gt;&gt; &lt;&lt; &gt;&gt;&gt;</code></li><li><code>&gt; &lt; = &gt;= &lt;=</code></li><li><code>== !=</code></li><li><code>&amp;</code></li><li><code>^</code></li><li><code>|</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li><li><code>? :</code></li><li><code>=</code> //赋值</li></ol><h2 id="1-3-流程控制"><a href="#1-3-流程控制" class="headerlink" title="1.3  流程控制"></a>1.3  流程控制</h2><h3 id="1-3-1-判断"><a href="#1-3-1-判断" class="headerlink" title="1.3.1  判断"></a>1.3.1  判断</h3><h4 id="1-3-1-1-IF语句"><a href="#1-3-1-1-IF语句" class="headerlink" title="1.3.1.1  IF语句"></a>1.3.1.1  IF语句</h4><h4 id="1-3-1-2-switch语句"><a href="#1-3-1-2-switch语句" class="headerlink" title="1.3.1.2  switch语句"></a>1.3.1.2  switch语句</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">switch_study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> grade=sc.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;良&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;中&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;差&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-循环"><a href="#1-3-2-循环" class="headerlink" title="1.3.2  循环"></a>1.3.2  循环</h3><h4 id="1-3-2-1-WHILE"><a href="#1-3-2-1-WHILE" class="headerlink" title="1.3.2.1  WHILE"></a>1.3.2.1  WHILE</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xunhuan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a&gt;<span class="number">5</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ended&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-2-do-while"><a href="#1-3-2-2-do-while" class="headerlink" title="1.3.2.2  do while"></a>1.3.2.2  do while</h4><p><code>while</code>先判断再执行，<code>do-while</code>先执行后判断 </p><p><strong>demo1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">do_while</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">            index = index + <span class="number">1</span>; <span class="comment">// 这里怎么会是 +1 呢</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(index &lt;= <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;DONE.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// DONE.</span></span><br></pre></td></tr></table></figure><p><strong>demo2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">do_while</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        String password;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            password = sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="string">&quot;45634351&quot;</span>.equals(password));<span class="comment">//equals()方法用于将字符串与指定的对象比较。这里必须加一个分号。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;right&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-3-FOR"><a href="#1-3-2-3-FOR" class="headerlink" title="1.3.2.3  FOR"></a>1.3.2.3  FOR</h4><p><strong>demo1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOR</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>demo2：输出乘法口诀表</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j ++)&#123;</span><br><span class="line">                System.out.println(j + <span class="string">&quot;*&quot;</span> + i + <span class="string">&quot;=&quot;</span> + i * j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-4-FOREACH"><a href="#1-3-2-4-FOREACH" class="headerlink" title="1.3.2.4  FOREACH"></a>1.3.2.4  FOREACH</h4><p>遍历数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOR</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : arr)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-跳转"><a href="#1-3-3-跳转" class="headerlink" title="1.3.3  跳转"></a>1.3.3  跳转</h3><h4 id="1-3-3-1-break"><a href="#1-3-3-1-break" class="headerlink" title="1.3.3.1  break"></a>1.3.3.1  break</h4><p>在java中 break 语句作用是跳出距离最近的循环，但是可以通过给循环命名的方式跳出指定的for循环。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BREAK</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        a:<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">            b:<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span> a;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-2-continue"><a href="#1-3-3-2-continue" class="headerlink" title="1.3.3.2  continue"></a>1.3.3.2  continue</h4><p>跳到下一循环 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">20</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);<span class="comment">// 输出奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-实用用途"><a href="#1-4-实用用途" class="headerlink" title="1.4  实用用途"></a>1.4  实用用途</h2><h3 id="1-4-1-读取文件内容"><a href="#1-4-1-读取文件内容" class="headerlink" title="1.4.1  读取文件内容"></a>1.4.1  读取文件内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readFileContent</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        String tempStr;</span><br><span class="line">        <span class="keyword">while</span> ((tempStr = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            sbf.append(tempStr);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> sbf.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sbf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凡人修仙传</title>
      <link href="/2022/05/22/acg/fanren/"/>
      <url>/2022/05/22/acg/fanren/</url>
      
        <content type="html"><![CDATA[<h1 id="凡人修仙传"><a href="#凡人修仙传" class="headerlink" title="凡人修仙传"></a>凡人修仙传</h1><h2 id="51-再别天南51"><a href="#51-再别天南51" class="headerlink" title="51.  再别天南51"></a>51.  再别天南51</h2><p>​        这一集，陈巧倩那一段，完全能感受到女子的爱意柔情，什么修道长生似乎都不重要了，想起那首《女儿情》，说什么王权富贵，就问你女儿美不美，自己都想和陈巧倩找个地方厮守一生。<br>​        后面，大战画面，无数修士，场面震撼，如果自己是一名筑基修士，肯定泯然众生，当时的念头就是，自己应该修为有成，是元婴大修，坐看此番战争，翻手抹灭无数蝼蚁，主宰天地间。<br>​        两种截然相反的想法，都出现在你的一生中，就看你如何抉择，念头通达真不是那么容易的。小说里的心魔，读的时候觉得不过如此，现在通过动漫，看的感受颇深，我亦凡俗，绝非圣人。</p><p><img src="/2022/05/22/acg/fanren/1.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> acg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起风了</title>
      <link href="/2022/05/15/acg/qifengl/"/>
      <url>/2022/05/15/acg/qifengl/</url>
      
        <content type="html"><![CDATA[<p>《起风了》（風立ちぬ）是日本吉卜力工作室动画导演宫崎骏以在月刊《Model Graphix》上连载的漫画所改编的同名电影动画。2013 年 7 月 20 日在日本公映。剧情为混合改编了零式舰上战斗机设计者堀越二郎的故事、以及小说家堀辰雄作品《起风了》的内容。 </p><p>風立ちぬ </p><p>纵有疾风起，人生不言弃 </p><p>起风了，唯有努力生存</p><p><img src="/2022/05/15/acg/qifengl/1.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/4.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/2.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/3.png" alt="1"></p><p>将过多的财政收入投入军备竞赛而不去改造民生，国家未来的出路在哪里？ </p><p><img src="/2022/05/15/acg/qifengl/5.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/6.png" alt="1"></p><p>谁曾见过风？</p><p>你我皆不曾。</p><p>但看木叶舞枝头，</p><p>便晓风穿过。</p><p>谁曾见过风？</p><p>你我皆不曾。</p><p>但看万木垂梢首，</p><p>便晓风吹过。</p><p>——克里斯蒂娜·罗塞蒂《谁曾见过风》</p><p><img src="/2022/05/15/acg/qifengl/7.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/8.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/9.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/10.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/11.png" alt="1"></p><p><img src="/2022/05/15/acg/qifengl/15.png" alt="1"></p><p>那个没有满座高朋的婚礼，落樱花瓣里的菜穗子，是真的<strong>妾拟将身嫁与，一生休</strong>。病痛摧残她的身体，她就抹上胭脂水粉，二郎从来只是称赞她的美丽，所以她到生命的尽头也还要如此粉饰自己，到终于连化妆都掩盖不了自己的病容时，她便依偎在二郎的怀里，轻轻摘掉了他的眼镜。然后她不辞而别，飘逝在那阵大风里。</p><p><img src="/2022/05/15/acg/qifengl/12.png" alt="1"></p><p>冥冥之中，感到远方有珍贵之物在逝去，怅然若失。</p><p><img src="/2022/05/15/acg/qifengl/13.png" alt="1"></p><p>走了，一个美得像风的人</p><p><img src="/2022/05/15/acg/qifengl/14.png" alt="1"></p><p>再看看这个时代背景，像极了我们曾经的样子，落后于西方，一直在追赶，虽然一些领域有所成就但还是有很多领域存在差距。然而日本走上了军国主义的道路，我们却一直在和平发展的道路上前进，这是一件很伟大的事。我们用J20战斗机去威慑敌人维护和平，然后用经济的手段，比如“一带一路”和RECP这种互利共赢的方式来发展彼此。这才是卡普罗尼和堀越二郎（电影中）向往的样子吧！</p>]]></content>
      
      
      <categories>
          
          <category> acg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acg </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五一之行</title>
      <link href="/2022/05/05/life/20220502marriage/"/>
      <url>/2022/05/05/life/20220502marriage/</url>
      
        <content type="html"><![CDATA[<p>人生第一次作为伴郎参加婚礼，婚礼前一天下午就过去了，主要是去贴喜字，拍视频，晚上接亲，没事干还和其他伴郎一起打王者荣耀，用镜拿了五杀，用孙尚香还拿了16.1的评分，哈哈。</p><p>酒店是在度假地，风景确实不错，地方真的很大。</p><p><img src="/2022/05/05/life/20220502marriage/2.jpg" alt="img"></p><p><img src="/2022/05/05/life/20220502marriage/3.jpg" alt="img"></p><p><img src="/2022/05/05/life/20220502marriage/4.jpg" alt="img"></p><p><img src="/2022/05/05/life/20220502marriage/5.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
